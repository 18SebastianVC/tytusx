compararStrings() {
    t19 = P + 1;                -> Accediendo al primer parametro
    t20 = stack[t19];           -> H.36 - Referencia a id Consulta
    t19 = t19 + 1;
    t21 = stack[t19];           -> H.24 - Referencia a id simbolo

    t22 = heap[t20];            -> b - id de consulta
    if (t22 == 42) goto L19.1;
    goto L19;

    L19.1:
    gotoL23;

    L19:
    t22 = heap[t20];            -> b - codigo de caracter actual (idConsulta)
    t23 = heap[t21];            -> b - codigo de caracter actual (id Simbolo)
    if (t22 == t23) goto L20;
    goto L21;

    L20:
    if (t22 != -1) goto L22:
    goto L23;

    L22:
    t20 = t20 + 1;              -> H.37
    t21 = t21 + 1;              -> H.25
    goto L19;

    L21:
    stack[P] = 0;
    return;

    L23:
    stack[P] = 1;
    return;
}

consultaSimple() {
    t7 = P + 1;             -> Posicion del parametro en la pila
    t8 = stack[t7];         -> H.40 - Recuperar paramentro de pila (array entornos)
    t7 = t7 + 1;            -> posicion de inicio de id consulta
    t8.1 = stack[t7];       -> H.36 - referencia al id de consulta

    t9 = heap[t8];          -> 1 - Entorno actual (tamaño del array de entornos)
    t10 = 1                 -> contador de tamaño entornos
    t11 = t8 + 1            -> H.41 - referencia al primer entorno

    t11.1 = H;              -> H.42 - Espacio vacio donde se guardara el tamaño del array de nuevos entornos
    t11.2 = t11.1 + 1;      -> H.43 - Contador para entornos dentro del array
    heap[t11.1] = t9;        -> tamaño inicial de array de entornos
    t11.3 = t9 + 1;         ->  2 - Tamaño del arreglo mas 1
    H = H + t11.3;          -> H.44 - Espacios a reservar en el heap
    t11.4 = 0;              -> Tamaño que tendra el arreglo de entornos

    if (t9 > 0) goto L8;
    goto L9;

    L8:                          -> Recorrer entornos
    if (t10 <= t9) goto L10      -> (i <= entornos.length)
    goto L11;

    L10:
    t12 = heap[t11];            -> H.30 - entorno actual
    t13 = t12 + 1;              -> H.31 - Referencia a segundo atributo (tabla)
    t14 = heap[t13];            -> H.32 - Referencia a tamaño tabla
    t14.1 = heap[t14];          -> 1 - tamaño de la tabla
    t15 = 1;                    -> contador de simbolos en tabla
    t16 = t14 + 1;              -> H.33 - referencia al simbolo actual

    t16.1 = H                   -> H.44 - Espacio vacio donde se guardara el entorno
    t16.2 = t16.1;              -> H.44 - Contador para atributos del entornos
    H = H + 2;                  -> Reservando espacion para parametros del entorno
    t16.3 = heap[t12];          -> -1 - entorno anterior del entorno actual
    heap[t16.2] = t16.3;        -> -1 - Setear entorno anterior a nuevo entorno
    t16.2 = t16.2 + 1;          -> H.45 - Aumentando contador en heap
    t16.4 = H;                  -> H.46 - Inicio de tabla (Donde se guardara el tamaño del array de simbolos)
    H = H + 1;                  -> Aumentando indice de Heap a posicion libre
    t.16.5 = 0;                 -> Tamaño que tendra el arreglo

    if (t14.1 > 0) goto L12;
    goto L13;

    L12:                        -> Recorrer tabla
    if (t15 <= t14.1) goto L14;
    goto L15;

    L14:
    t17 = heap[t16];            -> H.19 - Simbolo actual - referencia al primer atributo
    t17.1 = t17 + 4;            -> H.23 - referencia al 5to atributo (tipo simbolo)
    t17.2 = heap[t17.1]         -> 1 - tipo de simbolo

    if (t17.2 == 0) goto L16.1 }"); -> 0 y 1 para etiqueta vacia o doble para comparar el string
    goto L17;                   -> Si no es tipo 0 se v a L17 que verifica si es tipo 1

    L16.1:
    goto L16;

    L17:
    if (t17.2 == 1) goto L16
    goto L18;                   -> No es ni tipo 1 ni 0

    L16:                        -> Nodo
    P = P + 3;                  -> Reservando espacio para return
    t18 = P + 1;                -> Moviendo puntero a espacio para 1er parametro
    stack[t18] = t8.1;          -> H.36 Enviando primer parametro (id consulta)
    t18 = 18 + 1;               -> Moviendo puntero a espacio para 2do parametro
    t18.1 = heap[t17];          -> H.24 - referencia al inicio del id del simbolo
    stack[t18] = t18.1;         -> H.24 - Enviando segundo parametro (id simbolo)
    compararStrings();
    t24 = stack[P];             -> 1 - Valor de retorno de la funcion compararStrings
    P = P - 3;

    if (t24 == 1) goto L24;
    goto L25;

    L24:
    //Agregar simbolo a nuevo entorno
    heap[H] = t17;
    H = H + 1;
    t16.5 = t16.5 + 1;          -> Aumentar tamaño del nuevo entorno

    L25:
    //no hacer nada

    L18:
    //No es nodo
    t15 = t15 + 1;              -> aumentar iterador de tabla
    t16 = t16 + 1;              -> aumentar al siguiente simbolo
    goto L12;

    L15:
    //Fin recorrido tabla
    heap[t16.4] = t16.5;          -> 1 - tamaño final de tabla del nuevo entorno
    heap[t16.2] = t16.4;          -> H.46 - Referencia al inicio de la tabla

    if (t16.5 > 0) goto L15.1;
    goto L15.2;

    L15.1:
    //Agregar nuevo entorno a array entornos que se regresara
    heap[t11.2] = t16.1;          -> H.44 referencia a nuevo entorno
    t11.2 = t11.2 + 1;            -> Aumentar contador de entornos dentro del array
    t11.4 = t11.4 + 1;            -> Aumentar tamaño de arreglo de entornos

    L15.2:
    //No hacer nada

    L13:
    //Tabla vacia
    //Aumentar iterador de entorno
    t10 = t10 + 1;                  -> Aumentar iterador de entornos
    t11 = t11 + 1;                  -> Aumentar al siguiente entorno
    goto L8;

    L11:
    Fin recorrido entornos
    heap[t11.1] = t11.4;            -> 1 - tamaño final del array de entornos

    L9:
    Entornos vacios
    stack[P] = t11.1;               -> H.42 - Referencia al nuevo array de entornos
}




recorrerConsultas() {
    //obtener parametros
    t0.1 = P + 1;
    t0.2 = stack[t0.1];         -> Recuperando referencia a consultas
    t0.1 = t0.1 + 1;
    t0.3 = stack[t0.1];         -> Recuperando referencia a entornos


    //t0 = stack[6]               -> H.38 - referencia a consultas
    t1 = heap[t0.2]               -> 1 - tamaño array consultas
    t2 = 1                      -> contador de tamaño consultas
    t3 = t0.2 + 1                 -> t3 = (38+1) = H.39 - referencia a primera consulta
    //t4 = stack[7]               -> H.40 - referencia al array de entornos (referencia)

    if (t1 > 0) goto L1;
    goto L2;

    L1:
    if (t2 <= t1) goto L3       (i <= consultas.length)
    goto L4

    L3:
    t5 = heap[t3]               -> H.34 - referencia a primera consulta -> primer atributo(tipo)
    t5.1 = heap[t5]             -> 1 - tipo de consulta
    t5.2 = t5 + 1;              -> H.35 referencia al segundo atributo de consulta
    t5.3 = heap[t5.2]           -> H.36 referencia al incio del id

    if (t5.1 == 1) goto L5;
    goto L6;

    L5:                         -> (Logica de consulta simple)
    P = noPosPila + 1;          -> espacio de return
    t6 = P + 1;                 -> espacio para el primer parametro
    stack[t6] = t0.3;             -> H.40 envia parametro de inicio de entornos
    t6 = t6 + 1;                -> espacio para el segundo parametro
    stack[t6] = t5.3;           -> H.36 - referencia al id de consulta
    consultaSimple();
    t25 = stack[P];             -> H.42 - Referencia a nuevo array de entornos
    P = P - noPosPila;          -> Regresamos puntero de P a 0
    t0.3 = t25;                 -> H.42 - Referencia a nuevo array de entornos

    L6:
    Comprobar los demas tipos

    t2 = t2 + 1;
    t3 = t3 + 1;
    goto L1;

    L4:
    //Fin recorrido consultas
    L2:
    stack[P] = t0.3;
    //No hay consultas
    //Devolver array de entornos
}



P = P + noP;                        -> Moviendo puntero para envio de parametros
t0 = P + 1;                         -> Moviendo puntero para primer parametro
t1 = stack[posConsultas];           -> Recuperando referencia de consultas
satck[t0] = t1;                     -> Seteando primer parametro (referencia a consultas)
t0 = t0 + 1;
t2 = stack[posEntornos];            -> Recuperando referencia de entornos
stack[t0] = t2;                     -> Seteando segundo parametro (referencia a entornos)
recorrerConsultas();
t3 = stack[P];
P = P -noP;

//imprimir resultado
P = P + noP;
t4 = P + 1;
stack[t4] = t3;
imprimirResultado();
t5 = stack[P];
P = P - noP;







<bookstore></bookstore>

imprimirResultado() {
    t0 = P + 1;                 -> Moviendo puntero para recuperar parametro
    t1 = stack[t0]              -> Recuperando array de entornos

    t2 = heap[t1];              -> tamaño del array de entornos
    t3 = 1;                     -> contador entornos
    t4 = t1 + 1;                -> primer entorno

    //Validado que haya al menos un entorno
    if (t2 > 0) goto L0;
    goto L1;

    L0:
    if (t3 <= t2) goto L2;
    goto L3;

    L2:
    t5 = heap[t4];              -> entorno actual
    t6 = t5 + 1;                -> Referencia a segundo atributo (tabla)
    t7 = heap[t6];              -> Referencia a tamaño tabla
    t8 = heap[t7];              -> tamaño de la tabla
    t9 = 1;                     -> contador de simbolos en tabla
    t10 = t7 + 1;               -> Referencia al simbolo actual

    if (t8 > 0) goto L4;
    goto L5;

    L4:
    if (t9 <= t8) goto L6;
    goto L7;

    L6:
    t11 = heap[t10];            -> Simbolo actual - Referencia a primer atributo
    t12 = t11 + 4;              -> Referencia al tipo de simbolo
    t13 = heap[t12];            -> Tipo de simbolo

    if (t13 == 0) goto L8;
    goto L9;

    L8:
    goto L10;

    L9:
    if (t13 == 1) goto L10;
    goto L11;

    L10:
    P = P + 3;                  -> Reservando espacio para return
    t14 = P + 1;                -> Moviendo puntero a espacio para parametro
    stack[t14] = t11;           -> Referencia de simbolo actual
    toTag();
    t15 = stack[P];             -> Recuperando valor del return (vacio)
    P = P - 3;

    L11:
    No es un nodo
    t9 = t9 + 1;
    t10 = t10 + 1;
    goto L4;

    L7:
    Fin recorrido tabla

    L5:
    Tabla de simbolos vacia
    t3 = t3 + 1;
    t4 = t4 + 1;
    goto L0;

    L3:
    Fin de recorrido entornos

    L1:
    Entornos vacios
    Fin funcion
    stack[P] = 1;
}

toTag() {
    t0 = P + 1;                 -> Moviendo puntero para recuperar parametro
    t1 = stack[t0];             -> H .19 - Recupeando referencia a simbolo

    t2 = t1 + 4;                -> Referencia a tipo de simbolo
    t3 = heap[t2];              -> Tipo de simbolo

    if (t3 == 1) goto L0;
    goto L1;

    L0:                         -> Es etiqueta normal
    printf("%c", (char)60);     -> "<"
    t4 = heap[t1];              -> referencia a inicio de id simbolo
    t5 = heap[t4];              -> primer caracter de id simbolo

    L2:
    if (t5 != -1) goto L3;
    goto L4;

    L3:
    printf("%c", (char)t5);
    t4 = t4 + 1;
    t5 = heap[t4];
    goto L2;

    L4:
    Fin imprimir id
    printf("%c", (char)62);     -> ">"

    //Etiqueta de cierre
    printf("%c", (char)60);     -> "<"
    printf("%c", (char)47);     -> "/"
    t6 = heap[t1];              -> referencia a inicio de id simbolo
    t7 = heap[t6];              -> primer caracter de id simbolo

    L5:
    if (t7 != -1) goto L6;
    goto L7;

    L6:
    printf("%c", (char)t7);
    t6 = t6 + 1;
    t7 = heap[t6];
    goto L5;

    L7:
    Fin imprimir id
    printf("%c", (char)62);     -> ">"

    L1:
    stack[P] = 1;
    Validar que sea etiqueta auto cerrada
}